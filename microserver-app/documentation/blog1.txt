Microserver implementation with C++
==================

Introduction
------------
Microservices architectures are becoming more common as a deploymentmodel for componentized systems. I will not go in depth on what is a microservice architecture. Martin Fowler gives a description of the microservice architecture on his website; see the following article about link:http://martinfowler.com/articles/microservices.html[microservices] from Martin Fowler and James Lewis.

I will show an implementation of a microservices server. This implementation uses minimal resources. The server will be deployed separate from services that use this server to provide services to the world.

Prerequisites
-------------
This server is based on the Poco Project libraries; see the link:http://pocoproject.org[Poco Project libraries]. This server must be compiled with an C++ C11 compatible compiler. To compile and link the microserver and the services that use this server CMake (3.3.2) is used to prepare the makefiles (GNU make 3.81). This software is developed on OS X Yosemite (10.10.5) with clang (700.1.81)A. The microserver has been tested on this platform. [A version has been build on Gentoo linux () with CMake () and GNU Make () on my continuous integration server. The microserver has also been tested on this Gentoo linux box.]

Running the microserver
-----------------------
After compiling you can start the microserver-app. The applications' configuration must be stored in a property file (the file extension for the property file must be .properties). By default the search path for the property file is the directory in which the application executable is stored, if not found at that location then /etc/executable name is searched and after that the /etc directory is searched for the property file. A location can be given by the means of the command line argument -c or --config with a full path to the property file. If this command line argument is given, it will have precedence over the default search paths. The microserver-app will not look into the default paths for a configuration file. When the microserver-app is started as a daemon, it will change the current working directory to "/" (root of the filesystem).

Note: Due to the fact that I can only develop and test under MAC OS X and linux, I didn't make the microserver search for the configuration properties file in different locations. Perhaps someone can test and deliver a patch (when needed) to create this functionality on windows.

In the configuration file the services are defined. Services are defined by an url, by a library that implements the service and by the fully qualified class that acts as the provider. A full path to the implementing library must also be given in the property file. When an URI is not defined in the configuration file the microserver will respond with a default 404 Not Found HTTP error. The microserver can use lazyloading to load the services libraries. The lazyloading property can be defined in the configuration (properties) file. When not defined the default value will be false, which means no lazyloading.

By default a status message can be requested by for instance a loadbalancer to get a 200 OK HTTP message. A response to a status request will contain a JSON with a status 200 message and the current load for the microserver. A status request can be done by requesting the following URI: http://host:port/status. Of course the host is the hostname of the server on which the microserver is deployed. The port is defined in the configuration file. When the port is not defined the default port is 9980.

Creating a library to handle requests
-------------------------------------
[INSERT A PICTURE OF THE CLASS DIAGRAM] The provider class must inherit from AbstractRequestHandler. As described in the poco documentation all classes loaded by a classloader must have a common base class. A base class is necessary because the microserver needs an interface to access the provider class. For the microserver this means that provider classes must inherit from AbstractRequestHandler. The provider class acts as a factory for classes that handle the actual requests. The classes that handle the actual requests must inherit from HTTPRequestHandler.

Configuration
-------------
Configuration items that (together) define a library and a provider class start with microserver.library. The following example defines a library with the name ms-hello-world-lib.

microserver.library.ms-hello-world-lib = /helloWorld
microserver.library.ms-hello-world-lib.path = /var/microservices/
microserver.library.ms-hello-world-lib.class = hello_world::MicroServerRequestHandlerProvider

It is advised to use namespaces in the library (isn't it always) that implements the provider class. I have the preference to re-use the class name MicroServerRequestHandlerProvider for consistency. By using a namespace the actual classes can use the same descriptive name and used next to each other. 

The full path must be given to he path configuraion item, because the dynamic class loader uses system wide predefined search paths. By using the full path name you can be sure that the dynamic class loader will find your library.

The configuration item that defines the library name (ms-hello-world-lib in the above example) also defines the URI that point to the service(s) which are provided. All URI's that start with /helloWorld in the above example will be handled by hello_world::MicroServerRequestHandlerProvider. This means for instance that host:port//helloWorld, but also host:port//helloWorld/SaySomething will be handled by the same provider class.

Logging
-------
Logging is defined in the configuration file. The default logger is the root logger and all loggers inherit from this logger. The logging framework of the poco project is structured as a logging hierarchy. See the poco project for more information. All microserver classes define their own logger, which inherits from the root logger. The logger name is the class name of the class in which the logger is defined. For example the logger that is defined in the class MicroServer goes by the name MicroServer. When needed you can define different log levels for different classes. See the HelloWorld example for a setup with different log levels for different classes.

The unavoidable HeloWorld example
---------------------------------
To show the setup and working of microserver a HelloWorld example is created. To play with the HelloWorld example you have to download the microserver sources and the HelloWorld sources from github and build the microserver and the HelloWorld library. Want to see the microserver in action without building it yourself? Go to link:http://examples.klabbers.nl/HelloWorld[HelloWorld].

SHOW THE SOURCE FOR HelloWorld CLASS

SHOW THE SOURCE FOR THE PROVIDER CLASS





REMOVE BEFORE PUBLICATION
-------------------------
like to use namespaces to make it possible to re-use classnames. A favorite is the classname MicroServerRequestHandlerProvider in my libraries with a namespace that is the library name. So for the ms-authenticator library the namespace name is
ms_authemnticator.

the this_is_my_library_name can exist more than one time, but the uri must be 
unique. The class must be a subclass of HTTPRequestHandler.

--Not implemented yet
You can set a status and shutdown url in the configuration when not set the default status and shutdown url will be used, this is /status and /shutdown.
/status: response will be json with status: 200 ({HTTPStatus: 200, HTTPStatusDescription: OK, CurrentLoad: 1}) or 503 (with time indication as given when going into shutdown, this will let all clients finish and then shutdown.

Make it reloading with status setup for loadbalancers, make a command that can be given locally or ip range
to reload config in x seconds. So the procedure is: set status to not available, do not accept new connections (reject everything except status and 
stop reloading) wait the given number of seconds (or the default seconds), after that reload the configuration and when that is finished, then set status to available and accept connections (first accept connections and then status update).

/maintenance (default is 20 minutes) the server will report a 503 status and gives the server 15 minutes (waaay to long) to finish their tasks and 5 minutes to reload the configuration or restart...

--Not implemented yet
If you want to service more than one uri from the one library you can use the 
following properties.
microserver.library.this_is_my_library_name.uri1 = an uri
microserver.library.this_is_my_library_name.uri1.class = a class
microserver.library.this_is_my_library_name.uri2 = an uri
microserver.library.this_is_my_library_name.uri2.class = a class

--Not implemented yet
detects it's free port automatically..... !!Implement this!!

---The authenticator service
/authenticator/
/authenticator/token
